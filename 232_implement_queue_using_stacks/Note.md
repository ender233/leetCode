
**算法**
堆栈和队列的差异点是,　前者先进后出,　后者是先进先出;
那么如果有两个堆栈 从其中之一按取出顺序放入另外一个, 实际上就达到了反序的效果了.
核心的接口就是取队列头,　和向队列尾推入数据, 那么用两个堆栈模拟正好.

**时间复杂度**:
`push`操作就是一个简单的入栈动作,　时间复杂度同`Container::push_back`, 常数.
`pop`有两种情况, 如果当前右堆栈有数据,　简单直接取出来就好. 如果没有,需要把左边的堆栈全部搬移过来.
平均复杂度也是一个常数(考虑一次插入之后读取一次),　也就是说每个元素的读取都对应一次搬运.

但是也有最差情况, 比如先放入10000个元素再读取队列头,　那么就得搬运一万次, **是不是可以改造stack,　栈的头尾互换下,然后和右栈交换占用空间, 连搬移都省了**

**空间复杂度**:
增加了一个堆栈的空间